<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI æ‰‹åŠ¿æ§åˆ¶ 3D ç²’å­ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* è§†é¢‘éšè—ï¼Œæˆ‘ä»¬åªéœ€è¦æ•°æ® */
        #input-video { display: none; }

        /* UI é¢æ¿ */
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            z-index: 100;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease;
        }

        h2 { margin: 0 0 15px 0; font-size: 18px; font-weight: 500; letter-spacing: 1px; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; font-size: 12px; opacity: 0.8; }
        
        /* æŒ‰é’®ç½‘æ ¼ */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }
        
        button:hover, button.active {
            background: rgba(0, 255, 170, 0.6);
            border-color: rgba(0, 255, 170, 1);
            transform: translateY(-2px);
        }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        input[type="color"] {
            width: 100%;
            height: 35px;
            border: none;
            background: transparent;
            cursor: pointer;
        }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            pointer-events: none;
        }

        .loading { color: #ffae00 !important; }
        .ready { color: #00ffaa !important; }

        /* å…¨å±æŒ‰é’® */
        #fullscreen-btn {
            margin-top: 10px;
            width: 100%;
            background: rgba(0, 150, 255, 0.3);
        }
    </style>
    <!-- å¼•å…¥ Three.js å’Œ MediaPipe -->
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- ç”¨äº MediaPipe çš„è§†é¢‘æµ -->
    <video id="input-video"></video>

    <!-- UI é¢æ¿ -->
    <div id="ui-container">
        <h2>ç²’å­æ§åˆ¶å°</h2>
        
        <div class="control-group">
            <label>åˆ‡æ¢æ¨¡å‹</label>
            <div class="btn-grid">
                <button onclick="switchShape('heart')" class="active">â¤ï¸ çˆ±å¿ƒ</button>
                <button onclick="switchShape('saturn')">ğŸª åœŸæ˜Ÿ</button>
                <button onclick="switchShape('flower')">ğŸŒ¸ èŠ±æœµ</button>
                <button onclick="switchShape('spiral')">ğŸŒ€ èºæ—‹(ä»¿ä½›åƒ)</button>
                <button onclick="switchShape('fireworks')">ğŸ† çƒŸèŠ±</button>
                <button onclick="switchShape('sphere')">ğŸŒ çƒä½“</button>
            </div>
        </div>

        <div class="control-group">
            <label>ç²’å­é¢œè‰²</label>
            <input type="color" id="color-picker" value="#00ffaa">
        </div>

        <button id="fullscreen-btn" onclick="toggleFullScreen()">â›¶ å…¨å±æ¨¡å¼</button>
        
        <div style="margin-top: 15px; font-size: 11px; color: #aaa; line-height: 1.4;">
            ğŸ‘‹ äº¤äº’è¯´æ˜:<br>
            1. å…è®¸æ‘„åƒå¤´æƒé™<br>
            2. ä¸¾èµ·æ‰‹ï¼Œæåˆæ‰‹æŒ‡ = ç²’å­æ”¶ç¼©<br>
            3. å¼ å¼€æ‰‹æŒ = ç²’å­æ‰©æ•£
        </div>
    </div>

    <div id="status" class="loading">ç³»ç»Ÿåˆå§‹åŒ–ä¸­... (è¯·ç­‰å¾…æ¨¡å‹åŠ è½½)</div>

    <script>
        // --- 1. å…¨å±€å˜é‡ä¸åˆå§‹åŒ– ---
        let scene, camera, renderer, particles;
        let geometry, material;
        const particleCount = 15000;
        let currentShape = 'heart';
        let targetPositions = []; 
        let currentPositions = [];
        
        // äº¤äº’çŠ¶æ€
        let handScale = 1.0; // æ‰‹åŠ¿æ§åˆ¶çš„ç¼©æ”¾ç³»æ•°
        let targetColor = new THREE.Color(0x00ffaa);

        // åˆå§‹åŒ– Three.js
        function initThree() {
            scene = new THREE.Scene();
            // æ·»åŠ ä¸€ç‚¹é›¾æ•ˆå¢åŠ æ·±åº¦æ„Ÿ
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            geometry = new THREE.BufferGeometry();
            
            // åˆå§‹åŒ–ä½ç½®æ•°ç»„
            const positions = new Float32Array(particleCount * 3);
            currentPositions = new Float32Array(particleCount * 3);
            
            // åˆå§‹éšæœºåˆ†å¸ƒ
            for(let i=0; i<particleCount*3; i++) {
                currentPositions[i] = (Math.random() - 0.5) * 100;
                positions[i] = currentPositions[i];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // åˆ›å»ºç²’å­æè´¨
            // ä½¿ç”¨ canvas ç”Ÿæˆä¸€ä¸ªåœ†å½¢çš„çº¹ç†ï¼Œæ¯”åŠ è½½å›¾ç‰‡æ›´å¿«
            const sprite = getSprite();
            material = new THREE.PointsMaterial({
                size: 0.5,
                color: targetColor,
                map: sprite,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // ç”Ÿæˆåˆå§‹å½¢çŠ¶æ•°æ®
            calculateShape('heart');

            // ç›‘å¬çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
            
            // ç›‘å¬é¢œè‰²å˜åŒ–
            document.getElementById('color-picker').addEventListener('input', (e) => {
                targetColor.set(e.target.value);
                material.color.set(targetColor);
            });

            animate();
        }

        // --- 2. å½¢çŠ¶ç”Ÿæˆé€»è¾‘ (æ•°å­¦å…¬å¼) ---
        function calculateShape(type) {
            targetPositions = [];
            const scale = 1.5; // åŸºç¡€ç¼©æ”¾

            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                // ä¸ºäº†åˆ†å¸ƒå‡åŒ€ï¼Œä½¿ç”¨å½’ä¸€åŒ–è¿›åº¦
                const t = i / particleCount; 
                const angle = t * Math.PI * 2 * 20; // ç”¨äºèºæ—‹ç­‰

                switch (type) {
                    case 'heart':
                        // çˆ±å¿ƒ parametric equation
                        // x = 16sin^3(t)
                        // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                        // z = variation
                        const beta = Math.random() * Math.PI * 2;
                        const r = Math.sqrt(Math.random()); // å†…éƒ¨å¡«å……
                        // è¿™é‡Œä½¿ç”¨éšæœºç‚¹æ‹’ç»é‡‡æ ·æ³•ç”Ÿæˆç«‹ä½“çˆ±å¿ƒï¼Œæˆ–è€…ç®€å•çš„å‚æ•°æ–¹ç¨‹
                        // ç®€å•ç‰ˆï¼š
                        const phi = Math.random() * Math.PI * 2;
                        const theta = Math.random() * Math.PI;
                        // è¿™é‡Œç”¨ä¸€ä¸ªå¸¸è§çš„ç«‹ä½“å¿ƒå½¢å…¬å¼
                        const u = Math.random() * Math.PI * 2;
                        const v = Math.random() * Math.PI;
                        x = 16 * Math.pow(Math.sin(v), 3) * Math.sin(u);
                        y = (13 * Math.cos(v) - 5 * Math.cos(2*v) - 2 * Math.cos(3*v) - Math.cos(4*v));
                        z = 6 * Math.pow(Math.sin(v), 3) * Math.cos(u);
                        // ç¨å¾®æ‰“æ•£ä¸€ç‚¹
                        x *= 0.8; y *= 0.8; z *= 0.8;
                        break;

                    case 'sphere':
                        const rad = 12;
                        const s_theta = Math.random() * Math.PI * 2;
                        const s_phi = Math.acos((Math.random() * 2) - 1);
                        x = rad * Math.sin(s_phi) * Math.cos(s_theta);
                        y = rad * Math.sin(s_phi) * Math.sin(s_theta);
                        z = rad * Math.cos(s_phi);
                        break;
                    
                    case 'saturn':
                        // 70% ç²’å­åšçƒï¼Œ30% ç²’å­åšç¯
                        if (i < particleCount * 0.6) {
                            const rad = 8;
                            const s_theta = Math.random() * Math.PI * 2;
                            const s_phi = Math.acos((Math.random() * 2) - 1);
                            x = rad * Math.sin(s_phi) * Math.cos(s_theta);
                            y = rad * Math.sin(s_phi) * Math.sin(s_theta);
                            z = rad * Math.cos(s_phi);
                        } else {
                            // ç¯ (Disk)
                            const innerR = 10;
                            const outerR = 18;
                            const ringR = innerR + Math.random() * (outerR - innerR);
                            const ringAng = Math.random() * Math.PI * 2;
                            x = ringR * Math.cos(ringAng);
                            z = ringR * Math.sin(ringAng); // å¹³æ”¾åœ¨xzå¹³é¢
                            y = (Math.random() - 0.5) * 0.5; // ç¨å¾®æœ‰ç‚¹åšåº¦
                            // å€¾æ–œåœŸæ˜Ÿç¯
                            const tilt = Math.PI / 6;
                            const tempY = y * Math.cos(tilt) - z * Math.sin(tilt);
                            const tempZ = y * Math.sin(tilt) + z * Math.cos(tilt);
                            y = tempY; z = tempZ;
                        }
                        break;

                    case 'flower':
                        // ç«ç‘°æ›²çº¿ r = cos(k * theta)
                        const f_ang = Math.random() * Math.PI * 2;
                        const f_rad = Math.abs(Math.cos(f_ang * 2.5)) * 15 + Math.random(); // 5ç“£èŠ±
                        // åŠ ä¸Šæ·±åº¦å½¢æˆèŠ±æœµå½¢çŠ¶
                        const f_depth = Math.pow(f_rad/15, 2) * 5; 
                        x = f_rad * Math.cos(f_ang);
                        y = f_rad * Math.sin(f_ang);
                        z = -f_depth + (Math.random()-0.5)*2;
                        break;
                    
                    case 'spiral':
                        // æ¨¡æ‹Ÿå¤æ‚ç»“æ„ (ç±»ä¼¼ä½›åƒåå§¿çš„æŠ½è±¡)
                        // ä½¿ç”¨ç¯å½¢ç»“ Torus Knot
                        const sk_u = Math.random() * Math.PI * 2 * 5; // è¿™é‡Œçš„å€æ•°å†³å®šåœˆæ•°
                        const sk_v = Math.random() * Math.PI * 2;
                        const p = 2, q = 3; // ç»“çš„å‚æ•°
                        const r_knot = 8 + 3 * Math.cos(p * sk_u);
                        x = r_knot * Math.cos(q * sk_u);
                        y = r_knot * Math.sin(q * sk_u);
                        z = 3 * Math.sin(p * sk_u);
                        
                        // åŠ ä¸Šä¸€äº›å‚ç›´åˆ†å¸ƒæ¨¡æ‹Ÿèº«ä½“
                        if (Math.random() > 0.8) {
                           x *= 0.2; y = (Math.random() - 0.5) * 20; z *= 0.2;
                        }
                        break;

                    case 'fireworks':
                        // çº¯éšæœºç‚¸å¼€
                        const fw_theta = Math.random() * Math.PI * 2;
                        const fw_phi = Math.acos((Math.random() * 2) - 1);
                        const fw_r = Math.random() * 25; // å¤§èŒƒå›´
                        x = fw_r * Math.sin(fw_phi) * Math.cos(fw_theta);
                        y = fw_r * Math.sin(fw_phi) * Math.sin(fw_theta);
                        z = fw_r * Math.cos(fw_phi);
                        break;

                    default:
                        x = (Math.random() - 0.5) * 20;
                        y = (Math.random() - 0.5) * 20;
                        z = (Math.random() - 0.5) * 20;
                }

                targetPositions.push(x, y, z);
            }
        }

        function switchShape(type) {
            currentShape = type;
            calculateShape(type);
            
            // UI æŒ‰é’®çŠ¶æ€æ›´æ–°
            document.querySelectorAll('.btn-grid button').forEach(btn => {
                btn.classList.remove('active');
                if(btn.innerText.toLowerCase().includes(type === 'spiral' ? 'èºæ—‹' : (type === 'sphere' ? 'çƒ' : (type==='saturn'?'åœŸæ˜Ÿ':(type==='flower'?'èŠ±':(type==='fireworks'?'çƒŸèŠ±':'çˆ±å¿ƒ')))))) {
                    btn.classList.add('active');
                }
            });
        }

        // --- 3. åŠ¨ç”»ä¸æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            const positions = particles.geometry.attributes.position.array;
            
            // ç¼“åŠ¨ç³»æ•°
            const lerpFactor = 0.05;

            // æ ¹æ®æ‰‹åŠ¿è®¡ç®—æ€»ç¼©æ”¾
            // é»˜è®¤1.0ï¼Œå¦‚æœæåˆåˆ™å˜å°(0.2)ï¼Œå¼ å¼€åˆ™å˜å¤§(2.0)
            const targetGlobalScale = handScale; 

            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // ç›®æ ‡ä½ç½®
                let tx = targetPositions[ix];
                let ty = targetPositions[iy];
                let tz = targetPositions[iz];

                // å¦‚æœæ˜¯çƒŸèŠ±æ¨¡å¼ï¼Œå¢åŠ åŠ¨æ€æ‰©æ•£
                if (currentShape === 'fireworks') {
                    // ç®€å•çš„æ—‹è½¬æ•ˆæœ
                    const time = Date.now() * 0.0005;
                    const oldTx = tx; 
                    tx = tx * Math.cos(time) - tz * Math.sin(time);
                    tz = oldTx * Math.sin(time) + tz * Math.cos(time);
                }

                // åº”ç”¨æ‰‹åŠ¿ç¼©æ”¾
                tx *= targetGlobalScale;
                ty *= targetGlobalScale;
                tz *= targetGlobalScale;

                // å™ªç‚¹è¿åŠ¨ï¼ˆè®©ç²’å­çœ‹èµ·æ¥æ˜¯æ´»çš„ï¼‰
                const time = Date.now() * 0.001;
                const noise = 0.2;
                tx += Math.sin(time + i) * noise;
                ty += Math.cos(time + i * 1.1) * noise;

                // æ’å€¼æ›´æ–°ä½ç½®
                positions[ix] += (tx - positions[ix]) * lerpFactor;
                positions[iy] += (ty - positions[iy]) * lerpFactor;
                positions[iz] += (tz - positions[iz]) * lerpFactor;
            }

            // ç²’å­æ•´ä½“æ—‹è½¬
            particles.rotation.y += 0.002;
            particles.rotation.z += 0.001;

            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- 4. MediaPipe æ‰‹åŠ¿æ£€æµ‹ ---
        const videoElement = document.getElementById('input-video');
        const statusElement = document.getElementById('status');

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // è·å–æ‹‡æŒ‡æŒ‡å°–(4)å’Œé£ŸæŒ‡æŒ‡å°–(8)çš„ä½ç½®
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                // è®¡ç®—è·ç¦» (ç®€å•æ¬§æ°è·ç¦»ï¼Œå¿½ç•¥Zè½´æ·±åº¦ä»¥ç®€åŒ–)
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // æ˜ å°„è·ç¦»åˆ°ç¼©æ”¾ç³»æ•°
                // distance é€šå¸¸åœ¨ 0.02 (æåˆ) åˆ° 0.5 (å¼ å¼€) ä¹‹é—´
                // æˆ‘ä»¬å°†å…¶æ˜ å°„åˆ° 0.5 åˆ° 2.5 çš„ç¼©æ”¾èŒƒå›´
                
                const minRaw = 0.05;
                const maxRaw = 0.4;
                const minScale = 0.1; // æåˆæ—¶ç¼©å¾—å¾ˆå°
                const maxScale = 2.5; // å¼ å¼€æ—¶æ‰©æ•£

                let normalized = (distance - minRaw) / (maxRaw - minRaw);
                normalized = Math.max(0, Math.min(1, normalized)); // Clamp 0-1

                // å¹³æ»‘è¿‡æ¸¡ handScale
                const targetScale = minScale + normalized * (maxScale - minScale);
                handScale += (targetScale - handScale) * 0.1; // ç®€å•çš„å¹³æ»‘æ»¤æ³¢

                statusElement.innerText = `æ£€æµ‹åˆ°æ‰‹åŠ¿ | è·ç¦»: ${distance.toFixed(2)} | ç¼©æ”¾: ${handScale.toFixed(2)}`;
                statusElement.classList.add('ready');
            } else {
                statusElement.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿ - è¯·ä¸¾èµ·æ‰‹";
                statusElement.classList.remove('ready');
                // æ— æ‰‹åŠ¿æ—¶ç¼“æ…¢æ¢å¤é»˜è®¤
                handScale += (1.0 - handScale) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onHandsResults);

        // å¯åŠ¨æ‘„åƒå¤´
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        // å¯åŠ¨é€»è¾‘
        cameraUtils.start()
            .then(() => {
                statusElement.innerText = "æ‘„åƒå¤´å·²å¯åŠ¨ï¼Œæ­£åœ¨åŠ è½½æ¨¡å‹...";
                initThree();
            })
            .catch(err => {
                statusElement.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + err;
                statusElement.style.color = 'red';
                // å³ä½¿æ‘„åƒå¤´å¤±è´¥ä¹Ÿåˆå§‹åŒ–3Dåœºæ™¯
                initThree();
            });


        // --- è¾…åŠ©åŠŸèƒ½ ---
        function getSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
    </script>
</body>
</html>